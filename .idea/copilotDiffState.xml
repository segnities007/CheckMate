<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/remove_comments.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/remove_comments.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;import sys, os, io&#10;from pathlib import Path&#10;&#10;# Remove comments from various source files across the repo.&#10;# - Backs up original file to &lt;file&gt;.bak&#10;# - Supports C-style (//, /* */) comment removal for .kt, .java, .kts, .gradle, .groovy, .js, .ts, .c, .cpp, .h, .swift&#10;# - Supports XML/HTML &lt;!-- --&gt; removal for .xml, .html, .md&#10;# - Supports hash '#' line comments for .properties, .pro, .env, .sh, .bash, .yml, .yaml (preserve shebang)&#10;#&#10;# This script uses a conservative lexer for C-style comments that avoids removing // or /* */ inside&#10;# string literals (single, double, and triple-quoted strings). It's not a full parser but works well&#10;# for typical source files in this repository.&#10;&#10;SKIP_DIRS = {&quot;.git&quot;, &quot;build&quot;, &quot;out&quot;, &quot;gradle&quot;, &quot;node_modules&quot;}&#10;MAX_FILE_SIZE = 2 * 1024 * 1024  # 2MB&#10;&#10;c_style_exts = {'.kt', '.java', '.kts', '.gradle', '.groovy', '.js', '.ts', '.jsx', '.tsx', '.c', '.cpp', '.h', '.hpp', '.swift', '.m', '.mm', '.scala', '.rs'}&#10;xml_like_exts = {'.xml', '.html', '.xhtml', '.htm', '.md'}&#10;hash_line_exts = {'.properties', '.pro', '.env', '.sh', '.bash', '.yml', '.yaml'}&#10;&#10;changed = []&#10;errors = []&#10;&#10;&#10;def strip_c_style_comments(text):&#10;    out = []&#10;    i = 0&#10;    n = len(text)&#10;    state = 'NORMAL'&#10;    while i &lt; n:&#10;        ch = text[i]&#10;        # NORMAL state&#10;        if state == 'NORMAL':&#10;            if text.startswith('&quot;&quot;&quot;', i):&#10;                # triple-quoted string start&#10;                out.append('&quot;&quot;&quot;')&#10;                i += 3&#10;                state = 'TRIPLE'&#10;                continue&#10;            if ch == '&quot;':&#10;                out.append(ch)&#10;                i += 1&#10;                state = 'DQUOTE'&#10;                continue&#10;            if ch == &quot;'&quot;:&#10;                out.append(ch)&#10;                i += 1&#10;                state = 'SQUOTE'&#10;                continue&#10;            if text.startswith('//', i):&#10;                # skip until end of line&#10;                i += 2&#10;                while i &lt; n and text[i] != '\n':&#10;                    i += 1&#10;                # preserve newline if present&#10;                continue&#10;            if text.startswith('/*', i):&#10;                i += 2&#10;                # skip until */&#10;                while i &lt; n and not text.startswith('*/', i):&#10;                    i += 1&#10;                i += 2 if i &lt; n else 0&#10;                continue&#10;            # otherwise copy char&#10;            out.append(ch)&#10;            i += 1&#10;            continue&#10;        elif state == 'DQUOTE':&#10;            if ch == '\\':&#10;                # escape sequence&#10;                out.append(text[i:i+2])&#10;                i += 2&#10;                continue&#10;            if ch == '&quot;':&#10;                out.append(ch)&#10;                i += 1&#10;                state = 'NORMAL'&#10;                continue&#10;            # inside double-quote&#10;            out.append(ch)&#10;            i += 1&#10;            continue&#10;        elif state == 'SQUOTE':&#10;            if ch == '\\':&#10;                out.append(text[i:i+2])&#10;                i += 2&#10;                continue&#10;            if ch == &quot;'&quot;:&#10;                out.append(ch)&#10;                i += 1&#10;                state = 'NORMAL'&#10;                continue&#10;            out.append(ch)&#10;            i += 1&#10;            continue&#10;        elif state == 'TRIPLE':&#10;            # keep everything until next triple quote&#10;            if text.startswith('&quot;&quot;&quot;', i):&#10;                out.append('&quot;&quot;&quot;')&#10;                i += 3&#10;                state = 'NORMAL'&#10;                continue&#10;            # otherwise append char&#10;            out.append(ch)&#10;            i += 1&#10;            continue&#10;    return ''.join(out)&#10;&#10;&#10;def strip_xml_comments(text):&#10;    # remove &lt;!-- ... --&gt; occurrences&#10;    out = []&#10;    i = 0&#10;    n = len(text)&#10;    while i &lt; n:&#10;        if text.startswith('&lt;!--', i):&#10;            i += 4&#10;            while i &lt; n and not text.startswith('--&gt;', i):&#10;                i += 1&#10;            i += 3 if i &lt; n else 0&#10;            continue&#10;        out.append(text[i])&#10;        i += 1&#10;    return ''.join(out)&#10;&#10;&#10;def strip_hash_comments(text, preserve_shebang=True):&#10;    lines = text.splitlines(keepends=True)&#10;    out_lines = []&#10;    for idx, line in enumerate(lines):&#10;        stripped = line.lstrip()&#10;        if preserve_shebang and idx == 0 and stripped.startswith('#!'):&#10;            out_lines.append(line)&#10;            continue&#10;        # find first non-whitespace char&#10;        leading_ws_len = len(line) - len(stripped)&#10;        if stripped.startswith('#'):&#10;            # remove entire line&#10;            # but keep newline if present to preserve line numbers&#10;            if line.endswith('\n'):&#10;                out_lines.append('\n')&#10;            else:&#10;                # drop last line completely&#10;                pass&#10;            continue&#10;        # inline hash comments: remove ' #...' only if hash is not in a value? We will remove inline comments after a space&#10;        # naive approach: if ' #' appears, strip from that point&#10;        idx_hash = line.find(' #')&#10;        if idx_hash != -1:&#10;            # keep up to idx_hash and newline&#10;            prefix = line[:idx_hash]&#10;            if line.endswith('\n'):&#10;                prefix += '\n'&#10;            out_lines.append(prefix)&#10;        else:&#10;            out_lines.append(line)&#10;    return ''.join(out_lines)&#10;&#10;&#10;def should_process(path: Path):&#10;    # skip large files and files in SKIP_DIRS&#10;    try:&#10;        if path.is_dir():&#10;            return False&#10;    except Exception:&#10;        return False&#10;    parts = set(path.parts)&#10;    if parts &amp; SKIP_DIRS:&#10;        return False&#10;    if path.name.endswith('.bak') or path.name.endswith('.orig'):&#10;        return False&#10;    try:&#10;        if path.stat().st_size &gt; MAX_FILE_SIZE:&#10;            return False&#10;    except Exception:&#10;        return False&#10;    return True&#10;&#10;&#10;def process_file(path: Path):&#10;    try:&#10;        text = path.read_text(encoding='utf-8')&#10;    except Exception as e:&#10;        errors.append((str(path), f'read_error: {e}'))&#10;        return&#10;    ext = path.suffix.lower()&#10;    new_text = None&#10;    if ext in c_style_exts:&#10;        new_text = strip_c_style_comments(text)&#10;    elif ext in xml_like_exts:&#10;        new_text = strip_xml_comments(text)&#10;    elif ext in hash_line_exts:&#10;        new_text = strip_hash_comments(text, preserve_shebang=True)&#10;    else:&#10;        # skip other types&#10;        return&#10;    if new_text is not None and new_text != text:&#10;        # backup&#10;        bak = path.with_suffix(path.suffix + '.bak')&#10;        try:&#10;            path.rename(bak)&#10;            bak.write_text(text, encoding='utf-8')&#10;            path.write_text(new_text, encoding='utf-8')&#10;            changed.append(str(path))&#10;        except Exception as e:&#10;            errors.append((str(path), f'write_error: {e}'))&#10;&#10;&#10;if __name__ == '__main__':&#10;    root = Path('.').resolve()&#10;    print('Scanning for files...')&#10;    for p in root.rglob('*'):&#10;        if not should_process(p):&#10;            continue&#10;        if p.suffix.lower() in c_style_exts | xml_like_exts | hash_line_exts:&#10;            process_file(p)&#10;    print('\nSummary:')&#10;    print(f'  Files changed: {len(changed)}')&#10;    for f in changed[:200]:&#10;        print('   -', f)&#10;    if len(changed) &gt; 200:&#10;        print('   - ... (truncated)')&#10;    if errors:&#10;        print('\nErrors:')&#10;        for e in errors:&#10;            print('   -', e)&#10;    print('\nBackups of modified files have been saved with a .bak suffix on the original filename.')&#10;    if not changed:&#10;        print('No changes made.')&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/remove_comments.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/remove_comments.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;...existing code...&#10;&quot;&quot;&quot;&#10;# ...existing code...&#10;#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Remove comments from source files in the repository while preserving string literals and shebangs.&#10;Backs up each changed file under .comment_backups/&lt;relative_path&gt;.bak&#10;Usage: python3 scripts/remove_comments.py [--dry-run] [--extensions .kt,.kts] [--exclude build,.git]&#10;&quot;&quot;&quot;&#10;import os&#10;import sys&#10;import io&#10;import argparse&#10;from pathlib import Path&#10;&#10;ROOT = Path(__file__).resolve().parents[1]&#10;BACKUP_DIR = ROOT / '.comment_backups'&#10;&#10;# File extensions grouped by comment style&#10;C_LIKE = {'.kt', '.kts', '.java', '.groovy', '.gradle', '.js', '.jsx', '.ts', '.tsx'}&#10;XML_LIKE = {'.xml', '.html', '.htm', '.md'}&#10;HASH_LIKE = {'.sh', '.bash', '.zsh', '.env', '.properties', '.yml', '.yaml'}&#10;&#10;# Some filenames to treat as shell (Dockerfile has no extension sometimes)&#10;SPECIAL_FILENAMES = {'gradlew', 'gradlew.bat', 'Dockerfile'}&#10;&#10;# --- comment removal helpers (improved) ---&#10;&#10;def remove_c_like_comments(s: str) -&gt; str:&#10;    out = []&#10;    i = 0&#10;    n = len(s)&#10;    in_block = False&#10;    in_line = False&#10;    in_double = False&#10;    in_single = False&#10;    in_triple = False  # for Kotlin triple-quoted &quot;&quot;&quot;&#10;    in_backtick = False  # for JS/TS template literals&#10;    while i &lt; n:&#10;        if in_block:&#10;            if s.startswith('*/', i):&#10;                in_block = False&#10;                i += 2&#10;            else:&#10;                i += 1&#10;        elif in_line:&#10;            if s[i] == '\n':&#10;                in_line = False&#10;                out.append('\n')&#10;                i += 1&#10;            else:&#10;                i += 1&#10;        elif in_triple:&#10;            if s.startswith('&quot;&quot;&quot;', i):&#10;                out.append('&quot;&quot;&quot;')&#10;                in_triple = False&#10;                i += 3&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;        elif in_backtick:&#10;            # preserve until next unescaped backtick&#10;            if s[i] == '\\':&#10;                if i + 1 &lt; n:&#10;                    out.append(s[i:i+2])&#10;                    i += 2&#10;                else:&#10;                    out.append(s[i])&#10;                    i += 1&#10;            elif s[i] == '`':&#10;                out.append('`')&#10;                in_backtick = False&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;        elif in_double:&#10;            if s[i] == '\\':&#10;                # preserve escaped char&#10;                if i + 1 &lt; n:&#10;                    out.append(s[i:i+2])&#10;                    i += 2&#10;                else:&#10;                    out.append(s[i])&#10;                    i += 1&#10;            elif s[i] == '&quot;':&#10;                out.append('&quot;')&#10;                in_double = False&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;        elif in_single:&#10;            if s[i] == '\\':&#10;                if i + 1 &lt; n:&#10;                    out.append(s[i:i+2])&#10;                    i += 2&#10;                else:&#10;                    out.append(s[i])&#10;                    i += 1&#10;            elif s[i] == &quot;'&quot;:&#10;                out.append(&quot;'&quot;)&#10;                in_single = False&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;        else:&#10;            # not in any string/comment&#10;            if s.startswith('/*', i):&#10;                in_block = True&#10;                i += 2&#10;            elif s.startswith('//', i):&#10;                in_line = True&#10;                i += 2&#10;            elif s.startswith('&quot;&quot;&quot;', i):&#10;                in_triple = True&#10;                out.append('&quot;&quot;&quot;')&#10;                i += 3&#10;            elif s[i] == '`':&#10;                in_backtick = True&#10;                out.append('`')&#10;                i += 1&#10;            elif s[i] == '&quot;':&#10;                in_double = True&#10;                out.append('&quot;')&#10;                i += 1&#10;            elif s[i] == &quot;'&quot;:&#10;                in_single = True&#10;                out.append(&quot;'&quot;)&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;    return ''.join(out)&#10;&#10;&#10;def remove_xml_comments(s: str) -&gt; str:&#10;    out = []&#10;    i = 0&#10;    n = len(s)&#10;    in_quote = None&#10;    while i &lt; n:&#10;        if in_quote:&#10;            if s[i] == '\\':&#10;                # preserve escaped&#10;                if i + 1 &lt; n:&#10;                    out.append(s[i:i+2])&#10;                    i += 2&#10;                else:&#10;                    out.append(s[i])&#10;                    i += 1&#10;            elif s[i] == in_quote:&#10;                out.append(s[i])&#10;                in_quote = None&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;        else:&#10;            if s.startswith('&lt;!--', i):&#10;                # skip until --&gt;&#10;                j = s.find('--&gt;', i+4)&#10;                if j == -1:&#10;                    # rest of file is comment -&gt; stop&#10;                    break&#10;                else:&#10;                    i = j + 3&#10;            elif s[i] == '&quot;' or s[i] == &quot;'&quot;:&#10;                in_quote = s[i]&#10;                out.append(s[i])&#10;                i += 1&#10;            else:&#10;                out.append(s[i])&#10;                i += 1&#10;    return ''.join(out)&#10;&#10;&#10;def remove_hash_comments(s: str, keep_shebang=True) -&gt; str:&#10;    lines = s.splitlines(keepends=True)&#10;    out_lines = []&#10;    for idx, line in enumerate(lines):&#10;        stripped = line.lstrip()&#10;        if keep_shebang and idx == 0 and stripped.startswith('#!'):&#10;            out_lines.append(line)&#10;            continue&#10;        # If line's first non-space is # or ! -&gt; drop entire line&#10;        if stripped.startswith('#') or stripped.startswith('!'):&#10;            if line.endswith('\n'):&#10;                out_lines.append('\n')&#10;            else:&#10;                pass&#10;            continue&#10;        # otherwise, remove inline # comments but only when # is preceded by whitespace&#10;        new_line = []&#10;        in_double = False&#10;        in_single = False&#10;        i = 0&#10;        n = len(line)&#10;        removed = False&#10;        while i &lt; n:&#10;            ch = line[i]&#10;            if ch == '\\':&#10;                if i + 1 &lt; n:&#10;                    new_line.append(line[i:i+2])&#10;                    i += 2&#10;                else:&#10;                    new_line.append(ch)&#10;                    i += 1&#10;                continue&#10;            if in_double:&#10;                if ch == '&quot;':&#10;                    in_double = False&#10;                new_line.append(ch)&#10;                i += 1&#10;                continue&#10;            if in_single:&#10;                if ch == &quot;'&quot;:&#10;                    in_single = False&#10;                new_line.append(ch)&#10;                i += 1&#10;                continue&#10;            if ch == '&quot;':&#10;                in_double = True&#10;                new_line.append(ch)&#10;                i += 1&#10;                continue&#10;            if ch == &quot;'&quot;:&#10;                in_single = True&#10;                new_line.append(ch)&#10;                i += 1&#10;                continue&#10;            if ch == '#':&#10;                prev = line[i-1] if i-1 &gt;= 0 else None&#10;                if prev is None or prev.isspace():&#10;                    removed = True&#10;                    break&#10;                else:&#10;                    new_line.append(ch)&#10;                    i += 1&#10;                    continue&#10;            else:&#10;                new_line.append(ch)&#10;                i += 1&#10;        if removed:&#10;            if line.endswith('\n'):&#10;                new_line.append('\n')&#10;            out_lines.append(''.join(new_line))&#10;        else:&#10;            out_lines.append(''.join(new_line))&#10;    return ''.join(out_lines)&#10;&#10;&#10;def process_file(path: Path, dry_run: bool = True) -&gt; bool:&#10;    rel = path.relative_to(ROOT)&#10;    ext = path.suffix&#10;    name = path.name&#10;    try:&#10;        orig = path.read_text(encoding='utf-8')&#10;    except Exception:&#10;        return False&#10;    new = orig&#10;    lower_name = name.lower()&#10;    if ext in C_LIKE or ext == '.gradle' or lower_name in SPECIAL_FILENAMES or ext in {'.kts'}:&#10;        new = remove_c_like_comments(orig)&#10;    elif ext in XML_LIKE:&#10;        new = remove_xml_comments(orig)&#10;    elif ext in HASH_LIKE or name in SPECIAL_FILENAMES:&#10;        new = remove_hash_comments(orig, keep_shebang=True)&#10;    else:&#10;        return False&#10;    if new != orig:&#10;        if dry_run:&#10;            print(f&quot;WILL MODIFY: {rel}&quot;)&#10;            return True&#10;        backup_path = BACKUP_DIR / rel&#10;        backup_path.parent.mkdir(parents=True, exist_ok=True)&#10;        backup_path.write_text(orig, encoding='utf-8')&#10;        path.write_text(new, encoding='utf-8')&#10;        print(f&quot;MODIFIED: {rel}&quot;)&#10;        return True&#10;    return False&#10;&#10;&#10;def is_text_file(path: Path) -&gt; bool:&#10;    try:&#10;        path.read_text(encoding='utf-8')&#10;        return True&#10;    except Exception:&#10;        return False&#10;&#10;&#10;def should_exclude(path: Path, exclude_dirs):&#10;    for part in path.parts:&#10;        if part in exclude_dirs:&#10;            return True&#10;    return False&#10;&#10;&#10;def main():&#10;    parser = argparse.ArgumentParser()&#10;    parser.add_argument('--root', default=str(ROOT), help='Repository root')&#10;    parser.add_argument('--dry-run', action='store_true', help='Do not write files; only list candidates')&#10;    parser.add_argument('--extensions', default=None, help='Comma-separated extensions to include (e.g. .kt,.kts,.xml)')&#10;    parser.add_argument('--exclude', default=None, help='Comma-separated directory names to exclude (e.g. build,.git)')&#10;    args = parser.parse_args()&#10;    root = Path(args.root)&#10;    dry_run = args.dry_run&#10;    exts = None&#10;    if args.extensions:&#10;        exts = {e.strip() if e.strip().startswith('.') else '.' + e.strip() for e in args.extensions.split(',')}&#10;    exclude_dirs = set()&#10;    if args.exclude:&#10;        exclude_dirs = {e.strip() for e in args.exclude.split(',')}&#10;    changed = []&#10;    scanned = 0&#10;    for dirpath, dirnames, filenames in os.walk(root):&#10;        if '.comment_backups' in dirpath:&#10;            continue&#10;        for fname in filenames:&#10;            path = Path(dirpath) / fname&#10;            if should_exclude(path, exclude_dirs):&#10;                continue&#10;            # skip build directories&#10;            if any(part in ('build', '.gradle', '.git', '.idea', 'out') for part in path.parts):&#10;                continue&#10;            ext = path.suffix&#10;            if exts is not None and ext not in exts and fname not in SPECIAL_FILENAMES:&#10;                continue&#10;            if fname in SPECIAL_FILENAMES or ext in C_LIKE or ext in XML_LIKE or ext in HASH_LIKE or ext == '.kts':&#10;                if not is_text_file(path):&#10;                    continue&#10;                scanned += 1&#10;                try:&#10;                    ok = process_file(path, dry_run=dry_run)&#10;                    if ok:&#10;                        changed.append(str(path.relative_to(root)))&#10;                except Exception as e:&#10;                    print(f&quot;ERROR processing {path}: {e}&quot;)&#10;    print('\nSummary:')&#10;    print(f'Scanned files: {scanned}')&#10;    print(f'Files to modify: {len(changed)}')&#10;    for c in changed:&#10;        print(' -', c)&#10;&#10;if __name__ == '__main__':&#10;    main()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>